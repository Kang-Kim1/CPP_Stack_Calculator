#include "UBCalculator.h"
#include "error_handling.h"
#include "Lexer.h"
#include <sstream>
#include <iostream>
#include <string>
#include <stack>
#include <map>
#include <vector>

using namespace std;


const map<char, char> UBCalculator::delimMatch = UBCalculator::createDelimMatch();
const map<char, int> UBCalculator::precedenceMap = UBCalculator::createPrecedenceMap();

const string UBCalculator::openDelims = "([{";
const string UBCalculator::closeDelims = ")]}";

void error_checker(Lexer);
void form_checker(Lexer, const string, const string);
int value_after_calc(vector<Token>);

vector<Token> new_vec;
stack<Token> new_stk;
map<string, int> var_val_map;
vector<Token> vec_tok;


void UBCalculator::setLine(string str)
{

        Lexer lex(str);

        //form check to detect error
        form_checker(lex, openDelims, closeDelims);
        error_checker(lex);

        //vector<Token> vec_toc;
        vec_tok = lex.tokenize();



        lex.restart();

    while(lex.has_more_token()){
                Token curr_tok = lex.next_token();
                string curr_val = curr_tok.value;
        cout << "curr_tok.value : "  << curr_tok.value <<endl;
        cout << "curr_tok.type : "  << curr_tok.type <<endl;

    switch (curr_tok.type){

    case ENDTOK :
        cout << "ENDTOK" << endl;
        break;
            case NUMBER :
        new_vec.push_back(curr_tok);
        break;

    case IDENT :
        new_vec.push_back(curr_tok);

        break;

    case OPERATOR :
        if(new_stk.empty()){
            new_stk.push(curr_tok);
        }else {
            if(curr_val == "+" || curr_val == "-"){
                            cout << "curr_tok.type : "  << curr_tok.type <<endl;
                    while(new_stk.top().value!="("){
                        Token temp = new_stk.top();
                        new_vec.push_back(temp);
                        new_stk.pop();
                        if(new_stk.empty())
                         break;
                    }
                    new_stk.push(curr_tok);

            } else if(curr_val == "*" || curr_val == "/"){

                if(new_stk.top().value=="*" || new_stk.top().value=="/"){
                    Token temp = new_stk.top();
                    new_vec.push_back(temp);
                    new_stk.pop();
                    new_stk.push(curr_tok);
                } else {
                    new_stk.push(curr_tok);
                }

            }
        }
        break;

    case DELIM :
        if(curr_val == "("){
            new_stk.push(curr_tok);
           } else if(curr_val == ")") {

                                                while(new_stk.top().value!="("){
                    Token temp = new_stk.top();
                    new_vec.push_back(temp);
                    new_stk.pop();
               }
               new_stk.pop();
           }
        break;
        }
        }
        while(!new_stk.empty()){
                Token temp = new_stk.top();
                new_vec.push_back(temp);
                new_stk.pop();
        }

        for(int i = 0; i < new_vec.size();i++){
        cout << new_vec.at(i).value << " ";
        }



        int answer = value_after_calc(new_vec);

        cout << "\n answer : " << answer << endl;


}

void error_checker(Lexer lex){
    Token tokens[0];
    int counter = 0;

    while(lex.has_more_token()){
        tokens[counter] = lex.next_token();
        cout << tokens[counter].value <<endl;
        if(tokens[counter].type == OPERATOR){
            throw Syntax_Error_Exception("Can't begin with OPERATOR");
        }

        if(tokens[counter].value == "="){
            if(tokens[counter-1].type == NUMBER && tokens[counter+1].type == NUMBER) throw Syntax_Error_Exception("Wrong form as NUMBER = NUMBER");
        }
        counter++;
    }
    if(sizeof(tokens)/sizeof(tokens[0]) < 3) throw Syntax_Error_Exception("Less than 3 tokens");

}


int value_after_calc(vector<Token> tok_vec){
    stack<Token> tok_stk;
    Token first_tok, second_tok;


        for(unsigned i = 0; i < tok_vec.size(); i++){
            cout << "i : " << tok_vec.at(i).value << endl;
        if(tok_vec.at(i).type == NUMBER || tok_vec.at(i).type == IDENT){
            tok_stk.push(tok_vec.at(i));
        }else if(tok_vec.at(i).type == OPERATOR){
                second_tok = tok_stk.top();
                tok_stk.pop();

                first_tok = tok_stk.top();
                tok_stk.pop();
        }

        if(first_tok.type == NUMBER && second_tok.type == IDENT) throw Syntax_Error_Exception();

        switch(tok_vec.at(i).value.at(0)){


            case '+' :
                {
                //Token calculated_tok(NUMBER, to_string(first_val+second_val));
                //cout << "pushed value :" << first_val+second_val <<endl;
                //tok_stk.push(calculated_tok);
                }
            break;

            case '-' :{

                //Token calculated_tok(NUMBER, to_string(first_val-second_val));
                //cout << "pushed value :" << first_val-second_val <<endl;
                //tok_stk.push(calculated_tok);
            }
            break;

            case '*' :
                {

                //Token calculated_tok(NUMBER, to_string(first_val*second_val));
                //cout << "pushed value :" << first_val*second_val <<endl;
                //tok_stk.push(calculated_tok);
                }
            break;

            case '/' :
                {
                //Token calculated_tok(NUMBER, to_string(first_val/second_val));
                //cout << "pushed value :" << first_val/second_val <<endl;
                //tok_stk.push(calculated_tok);
                }
            break;

            case '=' :
                {

                }
            }
        }

        cout<< endl;
    return 0;
   //return stoi(tok_stk.top().value);
}


void form_checker(Lexer lex, const string openDelims, const string closeDelims){
    Token tok;
    size_t p;
    stack<Token> temp_stk;


    while (lex.has_more_token()) {

            if ( (tok = lex.next_token()).type != DELIM ) continue;

            if (openDelims.find(tok.value) != string::npos) {
                temp_stk.push(tok);
                continue;
            }


            p = closeDelims.find(tok.value); // 0, 1, 2, or string::npos
            if (p != string::npos) {          // tok is a close delim
                if (temp_stk.empty() ||
                    openDelims.find(temp_stk.top().value) != p) {
                    temp_stk.push(tok); // make sure it's not empty
                    break;
                } else {
                    temp_stk.pop();
                }
            }

        }

    if (!temp_stk.empty()) {
            throw Syntax_Error_Exception("Expression is not well formed");
            while (!temp_stk.empty()) temp_stk.pop();
    }

}

void clearAll(){
    vec_tok.clear();
}


